# 2021-01-25

|Time (UTC)|Icon|Name|Message|
|---|---|---|---|
|01:35|![](https://secure.gravatar.com/avatar/1ac180f0868137292905c311b5fff781.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png)|spring-raining|C++„ÅßÊõ∏„Åã„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åßvivliosyle-cli„Å´ÁµÑ„ÅøËæº„ÇÄ„Å´„ÅØ„Å≤„Å®ÊâãÈñì„ÅÑ„Çä„Åæ„Åô„Å≠„ÄÇ„ÇÑ„Çã„Å®„Å™„Çã„Å®„Åä„Åù„Çâ„Åèpostprocess„ÅÆ„Çø„Ç§„Éü„É≥„Ç∞„ÅßÁµÑ„ÅøËæº„ÇÄÂΩ¢„Åã„Å™„Å®ÊÄù„ÅÑ„Åæ„Åô <https://github.com/vivliostyle/vivliostyle-cli/blob/develop/src/postprocess.ts><br><blockquote><pre>import fs from 'fs';<br>import os from 'os';<br>import path from 'upath';<br>import {<br>  PDFDict,<br>  PDFDocument,<br>  PDFHexString,<br>  PDFName,<br>  PDFNumber,<br>  PDFRef,<br>} from 'pdf-lib';<br>import * as pressReadyModule from 'press-ready';<br>import { v1 as uuid } from 'uuid';<br>import { Meta, TOCItem } from './broker';<br>import { startLogging, stopLogging } from './util';<br><br>export interface SaveOption {<br>  pressReady: boolean;<br>}<br><br>const prefixes = {<br>  dcterms: '<http://purl.org/dc/terms/>',<br>  meta: '<http://idpf.org/epub/vocab/package/meta/#>',<br>};<br><br>const metaTerms = {<br>  title: `${prefixes.dcterms}title`,<br>  creator: `${prefixes.dcterms}creator`,<br>  description: `${prefixes.dcterms}description`,<br>  subject: `${prefixes.dcterms}subject`,<br>  contributor: `${prefixes.dcterms}contributor`,<br>  language: `${prefixes.dcterms}language`,<br>  role: `${prefixes.meta}role`,<br>  created: `${prefixes.meta}created`,<br>  date: `${prefixes.meta}date`,<br>};<br><br>interface PDFTocItem extends TOCItem {<br>  children: PDFTocItem[];<br>  ref: PDFRef;<br>  parentRef: PDFRef;<br>}<br><br>export class PostProcess {<br>  static async load(pdf: Buffer): Promise&lt;PostProcess&gt; {<br>    const document = await PDFDocument.load(pdf);<br>    return new PostProcess(document);<br>  }<br><br>  private constructor(private document: PDFDocument) {}<br><br>  async save(output: string, { pressReady = false }: SaveOption) {<br>    const input = pressReady<br>      ? path.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`)<br>      : output;<br><br>    const pdf = await this.document.save();<br>    await fs.promises.writeFile(input, pdf);<br><br>    if (pressReady) {<br>      stopLogging('Running press-ready', 'üöÄ');<br>      await pressReadyModule.build({ input, output });<br>      startLogging();<br>    }<br>  }<br><br>  async metadata(tree: Meta) {<br>    this.document.setProducer('Vivliostyle');<br><br>    const title = tree[metaTerms.title]?.[0].v;<br>    if (title) {<br>      this.document.setTitle(title);<br>    }<br><br>    const author = tree[metaTerms.creator]?.map((item) =&gt; item.v)?.join('; ');<br>    if (author) {<br>      this.document.setAuthor(author);<br>    }<br><br>    const subject = tree[metaTerms.description]?.[0].v;<br>    if (subject) {<br>      this.document.setSubject(subject);<br>    }<br><br>    const keywords = tree[metaTerms.subject]?.map((item) =&gt; item.v);<br>    if (keywords) {<br>      this.document.setKeywords(keywords);<br>    }<br><br>    const creator = tree[metaTerms.contributor]?.find(<br>      (item) =&gt; item.r?.[metaTerms.role]?.[0].v === 'bkp',<br>    )?.v;<br>    if (creator) {<br>      this.document.setCreator(creator);<br>    }<br><br>    const language = tree[metaTerms.language]?.[0].v;<br>    if (language) {<br>      this.document.setLanguage(language);<br>    }<br><br>    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;<br>    const creationDate = creation &amp;&amp; new Date(creation);<br>    if (creationDate) {<br>      this.document.setCreationDate(creationDate);<br>    }<br>  }<br><br>  async toc(items: TOCItem[]) {<br>    if (!items || !items.length) {<br>      return;<br>    }<br><br>    const addRefs = (items: TOCItem[], parentRef: PDFRef): PDFTocItem[] =&gt;<br>      items.map((item) =&gt; {<br>        const ref = this.document.context.nextRef();<br>        return {<br>          ...item,<br>          parentRef,<br>          ref,<br>          children: addRefs(item.children, ref),<br>        };<br>      });<br>    const countAll = (items: PDFTocItem[]): number =&gt;<br>      items.reduce((sum, item) =&gt; sum + countAll(item.children), items.length);<br>    const addObjectsToPDF = (items: PDFTocItem[]) =&gt; {<br>      for (const [i, item] of items.entries()) {<br>        const child = PDFDict.withContext(this.document.context);<br>        child.set(PDFName.of('Title'), PDFHexString.fromText(item.title));<br>        child.set(PDFName.of('Dest'), PDFName.of(item.id));<br>        child.set(PDFName.of('Parent'), item.parentRef);<br>        const prev = items[i - 1];<br>        if (prev) {<br>          child.set(PDFName.of('Prev'), prev.ref);<br>        }<br>        const next = items[i + 1];<br>        if (next) {<br>          child.set(PDFName.of('Next'), next.ref);<br>        }<br>        if (item.children.length) {<br>          child.set(PDFName.of('First'), item.children[0].ref);<br>          child.set(<br>            PDFName.of('Last'),<br>            item.children[item.children.length - 1].ref,<br>          );<br>          child.set(PDFName.of('Count'), PDFNumber.of(countAll(item.children)));<br>        }<br>        this.document.context.assign(item.ref, child);<br>        addObjectsToPDF(item.children);<br>      }<br>    };<br><br>    const outlineRef = this.document.context.nextRef();<br>    const itemsWithRefs = addRefs(items, outlineRef);<br>    addObjectsToPDF(itemsWithRefs);<br><br>    const outline = PDFDict.withContext(this.document.context);<br>    outline.set(PDFName.of('First'), itemsWithRefs[0].ref);<br>    outline.set(<br>      PDFName.of('Last'),<br>      itemsWithRefs[itemsWithRefs.length - 1].ref,<br>    );<br>    outline.set(PDFName.of('Count'), PDFNumber.of(countAll(itemsWithRefs)));<br>    this.document.context.assign(outlineRef, outline);<br>    this.document.catalog.set(PDFName.of('Outlines'), outlineRef);<br>  }<br>}<br></pre></blockquote>|
|01:35|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|üá¨üáß: It's written in C ++, so it takes a while to incorporate it into vivliosyle-cli. When it comes to doing it, I think that it will probably be incorporated at the timing of postprocess <https://github.com/vivliostyle/vivliostyle-cli/blob/develop/src/postprocess.ts><br><blockquote><pre>import fs from 'fs';<br>import os from 'os';<br>import path from 'upath';<br>import {<br>  PDFDict,<br>  PDFDocument,<br>  PDFHexString,<br>  PDFName,<br>  PDFNumber,<br>  PDFRef,<br>} from 'pdf-lib';<br>import * as pressReadyModule from 'press-ready';<br>import { v1 as uuid } from 'uuid';<br>import { Meta, TOCItem } from './broker';<br>import { startLogging, stopLogging } from './util';<br><br>export interface SaveOption {<br>  pressReady: boolean;<br>}<br><br>const prefixes = {<br>  dcterms: '<http://purl.org/dc/terms/>',<br>  meta: '<http://idpf.org/epub/vocab/package/meta/#>',<br>};<br><br>const metaTerms = {<br>  title: `${prefixes.dcterms}title`,<br>  creator: `${prefixes.dcterms}creator`,<br>  description: `${prefixes.dcterms}description`,<br>  subject: `${prefixes.dcterms}subject`,<br>  contributor: `${prefixes.dcterms}contributor`,<br>  language: `${prefixes.dcterms}language`,<br>  role: `${prefixes.meta}role`,<br>  created: `${prefixes.meta}created`,<br>  date: `${prefixes.meta}date`,<br>};<br><br>interface PDFTocItem extends TOCItem {<br>  children: PDFTocItem[];<br>  ref: PDFRef;<br>  parentRef: PDFRef;<br>}<br><br>export class PostProcess {<br>  static async load(pdf: Buffer): Promise&lt;PostProcess&gt; {<br>    const document = await PDFDocument.load(pdf);<br>    return new PostProcess(document);<br>  }<br><br>  private constructor(private document: PDFDocument) {}<br><br>  async save(output: string, { pressReady = false }: SaveOption) {<br>    const input = pressReady<br>      ? path.join(os.tmpdir(), `vivliostyle-cli-${uuid()}.pdf`)<br>      : output;<br><br>    const pdf = await this.document.save();<br>    await fs.promises.writeFile(input, pdf);<br><br>    if (pressReady) {<br>      stopLogging('Running press-ready', 'üöÄ');<br>      await pressReadyModule.build({ input, output });<br>      startLogging();<br>    }<br>  }<br><br>  async metadata(tree: Meta) {<br>    this.document.setProducer('Vivliostyle');<br><br>    const title = tree[metaTerms.title]?.[0].v;<br>    if (title) {<br>      this.document.setTitle(title);<br>    }<br><br>    const author = tree[metaTerms.creator]?.map((item) =&gt; item.v)?.join('; ');<br>    if (author) {<br>      this.document.setAuthor(author);<br>    }<br><br>    const subject = tree[metaTerms.description]?.[0].v;<br>    if (subject) {<br>      this.document.setSubject(subject);<br>    }<br><br>    const keywords = tree[metaTerms.subject]?.map((item) =&gt; item.v);<br>    if (keywords) {<br>      this.document.setKeywords(keywords);<br>    }<br><br>    const creator = tree[metaTerms.contributor]?.find(<br>      (item) =&gt; item.r?.[metaTerms.role]?.[0].v === 'bkp',<br>    )?.v;<br>    if (creator) {<br>      this.document.setCreator(creator);<br>    }<br><br>    const language = tree[metaTerms.language]?.[0].v;<br>    if (language) {<br>      this.document.setLanguage(language);<br>    }<br><br>    const creation = (tree[metaTerms.created] || tree[metaTerms.date])?.[0].v;<br>    const creationDate = creation &amp;&amp; new Date(creation);<br>    if (creationDate) {<br>      this.document.setCreationDate(creationDate);<br>    }<br>  }<br><br>  async toc(items: TOCItem[]) {<br>    if (!items || !items.length) {<br>      return;<br>    }<br><br>    const addRefs = (items: TOCItem[], parentRef: PDFRef): PDFTocItem[] =&gt;<br>      items.map((item) =&gt; {<br>        const ref = this.document.context.nextRef();<br>        return {<br>          ...item,<br>          parentRef,<br>          ref,<br>          children: addRefs(item.children, ref),<br>        };<br>      });<br>    const countAll = (items: PDFTocItem[]): number =&gt;<br>      items.reduce((sum, item) =&gt; sum + countAll(item.children), items.length);<br>    const addObjectsToPDF = (items: PDFTocItem[]) =&gt; {<br>      for (const [i, item] of items.entries()) {<br>        const child = PDFDict.withContext(this.document.context);<br>        child.set(PDFName.of('Title'), PDFHexString.fromText(item.title));<br>        child.set(PDFName.of('Dest'), PDFName.of(item.id));<br>        child.set(PDFName.of('Parent'), item.parentRef);<br>        const prev = items[i - 1];<br>        if (prev) {<br>          child.set(PDFName.of('Prev'), prev.ref);<br>        }<br>        const next = items[i + 1];<br>        if (next) {<br>          child.set(PDFName.of('Next'), next.ref);<br>        }<br>        if (item.children.length) {<br>          child.set(PDFName.of('First'), item.children[0].ref);<br>          child.set(<br>            PDFName.of('Last'),<br>            item.children[item.children.length - 1].ref,<br>          );<br>          child.set(PDFName.of('Count'), PDFNumber.of(countAll(item.children)));<br>        }<br>        this.document.context.assign(item.ref, child);<br>        addObjectsToPDF(item.children);<br>      }<br>    };<br><br>    const outlineRef = this.document.context.nextRef();<br>    const itemsWithRefs = addRefs(items, outlineRef);<br>    addObjectsToPDF(itemsWithRefs);<br><br>    const outline = PDFDict.withContext(this.document.context);<br>    outline.set(PDFName.of('First'), itemsWithRefs[0].ref);<br>    outline.set(<br>      PDFName.of('Last'),<br>      itemsWithRefs[itemsWithRefs.length - 1].ref,<br>    );<br>    outline.set(PDFName.of('Count'), PDFNumber.of(countAll(itemsWithRefs)));<br>    this.document.context.assign(outlineRef, outline);<br>    this.document.catalog.set(PDFName.of('Outlines'), outlineRef);<br>  }<br>}<br></pre></blockquote>|
