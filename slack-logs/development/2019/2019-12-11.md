# 2019-12-11

|Time|Icon|Name|Message|
|---|---|---|---|
|08:55|![](https://avatars.slack-edge.com/2018-04-27/354445776386_e258f5ed5ba887b08668_72.jpg)|shinyu|*monorepo化のついでに、ビルドスクリプト類の改善要望*<br><br>vivliostyle.js と vivliostyle-ui がどちらも JavaScript から TypeScript に移行しましたが、ビルドスクリプト類がそれ以前より少し使いにくくなりました。それを改善したいです。<br><br>- 以前は、vivliostyle.js をビルドしなくても、vivliostyle-ui 側で `npm run build-dev` とするだけで開発版の　Vivliostyle Viewer ができた。ソースが JavaScript なので、そのままブラウザで動いてデバッグもできた。それが今は、vivliostyle.js と vivliostyle-ui の両方で `npm run build-dev` が必要。<br>- 以前は、vivliostyle-ui の `npm run serve-dev` は `npm run build-dev` と同じビルドを行ってからWebサーバーを起動するものだった。それが今は、 `npm run build-dev` を行ってから、 `npm run serve-dev` を行う必要がある。そのうえ、それらの処理内容に重複がある。 production版用の `npm run serve` と `npm run build` も同様。<br>- 以前は、vivliostyle-ui の `npm run serve-dev` でのブラウザでの動作テスト中に、JavaScriptのソースコード（vivliostyle.js でも vivliostyle-ui でも）を修正すると、すぐに動作に反映された。それが今は、vivliostyle.js、vivliostyle-ui 両方の `npm run build-dev` での再ビルドが必要。<br><br>それから、production版であってもデバッグができるように（とくに gh-pages 上の Vivliostyle Viewer がデバッグ実行できてほしい）、vivliostyle.js の source map が、vivliostyle-ui に webpack でまとめられたときに消えてしまっているのを直したいと思っていました。これを使えばよい?: <https://github.com/webpack-contrib/source-map-loader><br><blockquote>extract sourceMappingURL comments from modules and offer it to webpack</blockquote>|
|09:01|![](https://avatars.slack-edge.com/2019-05-15/624511073651_25909952cd7a069ceed2_72.png)|akabeko|参考になるかわかりませんが、私は npm-scripts を組み合わせるのに npm-run-all を利用しています。<br><br>npm-run-all - npm<br><https://www.npmjs.com/products/pro?utm_source=house&amp;utm_medium=upsellbox&amp;utm_campaign=Proongoingpromo><br><br>これを使うと複数の npm-scripts を簡単に組み合わせられ、それらの実行方法も同期、非同期にできます。<br>シェルのパイプ処理における OS の差も抽象化してくれるので、クロスプラットフォーム対応の面でもオススメです。<br><blockquote>npm | Pro</blockquote>|
|09:01|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: I'm not sure if it helps, but I use npm-run-all to combine npm-scripts.<br><br>npm-run-all-npm<br><https://www.npmjs.com/products/pro?utm_source=house&amp;utm_medium=upsellbox&amp;utm_campaign=Proongoingpromo><br><br>Using this, you can easily combine multiple npm-scripts and execute them synchronously or asynchronously.<br>It also abstracts the OS differences in shell pipe processing, so it is also recommended for cross-platform support.|
|15:34|![](https://secure.gravatar.com/avatar/7fef90f6ef611e0cc71857ab8251f0c8.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0006-72.png)|U|確かに現状だとビルドステップが煩雑になっているので改善したい箇所です。Monorepo化に伴い親となるルートpackage.jsonが生まれるので、そちらにcoreのwatch&amp;buildとuiのserveを並列起動するnpm-run-allスクリプト（あるいは単に `lerna run --parallel`）を用意することで、coreの変更をjsにビルドし、それをuiにすぐに反映させるワークフローを作ることができそうです。|
|15:34|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: Certainly, the build step is complicated in the current situation, so it is a part that I want to improve. Since the parent package package.json is born with Monorepo conversion, prepare an npm-run-all script (or simply `lerna run --parallel`) that runs the core watch &amp; amp; build and ui serve in parallel. It seems that we can build a workflow that builds core changes into js and immediately reflects them in ui.|
