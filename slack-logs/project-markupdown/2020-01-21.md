# 2020-01-21

|Time (UTC)|Icon|Name|Message|
|---|---|---|---|
|00:42|![](https://secure.gravatar.com/avatar/8adee9b4425232f1c23d6592a5d8c807.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0015-72.png)|dynamis|あ、そういうことでしたか。何か村上さんとお話ししたときとさっと調べた用語があってないなと思ってはいました。(こちら見落としてました、ご指摘感謝！)<br><https://github.com/vivliostyle/discussion/wiki/slack-development-2019-12-07|https://github.com/vivliostyle/discussion/wiki/slack-development-2019-12-07>|
|00:42|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: Oh, was that the case? When I talked to Mr. Murakami, I thought there wasn't a term I looked up quickly. (I overlooked this, thanks for pointing out!)<br><https://github.com/vivliostyle/discussion/wiki/slack-development-2019-12-07|https://github.com/vivliostyle/discussion/wiki/slack-development-2019-12-07>|
|06:43|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|<blockquote>HTML 埋め込みの嵐か変換後の HTML に class 付与作業が別途必要とかなるので。</blockquote>これは本当に解決すべき問題です。各セクションにあるブロック要素に対してちょっとした視覚的差別化を与えたくなった場合でも、Markdownにそのような記法が存在しないためHTMLを書く羽目になってしまいます。<br>局所的にしか使用しないコンポーネントであればHTMLを書いても良いと考えることはできますが、頻出する単純なコンポーネントについては、糖衣構文によるサポートを受けられるようにしたいです。|
|06:43|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: &amp; gt; Because it is necessary to add class to HTML embedded storm or converted HTML.<br>This is really a problem to be solved. If you want to give a bit of visual differentiation to the block elements in each section, you still have to write HTML because Markdown does not have such a notation.<br>You can think that you can write HTML for components that are used only locally, but I would like to be able to receive support for sugary syntax for frequently occurring simple components.|
|06:47|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|それを解決するため、Scoped block（あるいはNamed block）という記法を導入します。<br><br>```===section-author<br>uetchy<br>===<pre>これは<br></pre>&lt;div class="section-author"&gt;<br>  &lt;p&gt;uetchy&lt;/p&gt;<br>&lt;/div&gt;```<br>に変換されます。=の数を増やせばネストも出来ます。<br>これにより、CSSを使って特定のブロックの表現を制御することが出来るようになります。<br>構文については今後の議論で改善していきましょう。|
|06:47|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: To solve it, we introduce a notation called Scoped block (or Named block).<br><br>`` `md<br>=== section-author<br>uetchy<br>=== `` `<br>this is<br><br>`` `html<br>&amp; lt; div class = "section-author" &amp; gt;<br>  &amp; lt; p &amp; gt; uetchy &amp; lt; / p &amp; gt;<br>&amp; lt; / div &amp; gt; `` `<br>Is converted to You can nest by increasing the number of =.<br>This allows you to control the representation of specific blocks using CSS.<br>We will improve the syntax in future discussions.|
|06:48|![](https://avatars.slack-edge.com/2019-05-15/624511073651_25909952cd7a069ceed2_72.png)|akabeko|GFM のように HTML 埋め込みするものだと HTML はそのまま解釈されて内包された Markdown 記法は無視されます。<br>このルールを踏襲するなら、糖衣構文は HTML ではなく Markdown 側の拡張ですかね。<br><br>コード ブロックのように行頭に始点・終点の記法を設け、その範囲を `&lt;div class="foo"&gt;` とする。<br>すれ違いでしたが↑で `@uetchy` さんが提案しているような感じで。|
|06:49|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: If you embed HTML like GFM, HTML is interpreted as it is and the included Markdown notation is ignored.<br>If you follow these rules, isn't sugar syntax an extension of Markdown, not HTML?<br><br>Set the notation of the start point and end point at the beginning of a line like a code block, and set the range to `&amp; lt; div class =" foo "&amp; gt;`.<br>It was a pass, but it looks like Pode proposed.|
|06:54|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|### Nested named block<br><br>```===section-author<br><br>uetchy<br><br>====author-homepage<br><https://uechi.io><br>====<br>===```<br>```&lt;div class="section-author"&gt;<br>  &lt;p&gt;uetchy&lt;/p&gt;<br>  &lt;div class="author-homepage"&gt;<br>    &lt;a href="<https://uechi.io>"&gt;<https://uechi.io>&lt;/a&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;```|
|06:54|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇯🇵: ###ネストされた名前付きブロック<br><br>`` `md<br>===セクション作成者<br><br>エッチな<br><br>==== author-homepage<br><https://uechi.io><br>====<br>=== `` `<br>`` `html<br>＆lt; div class = "section-author"＆gt;<br>  ＆lt; p＆gt; uetchy＆lt; / p＆gt;<br>  ＆lt; div class = "author-homepage"＆gt;<br>    ＆lt; a href = "<https://uechi.io>"＆gt; <https://uechi.io>＆lt; / a＆gt;<br>  ＆lt; / div＆gt;<br>＆lt; / div＆gt; `` `|
|06:57|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|画像の横カラム対応については、Deckset Markdown方言が参考になりました。<br><https://docs.deckset.com/English.lproj/Media/02-inline-images.html><br><br>```![](img1)![](img2)```<br>を2カラム画像と認識して、CSSでスタイリング出来るよう良い感じのHTMLに変換するイメージです。<br><blockquote>Media, Working with Inline Images</blockquote>|
|06:57|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: The Deckset Markdown dialect was helpful for supporting horizontal columns in images.<br><https://docs.deckset.com/English.lproj/Media/02-inline-images.html><br><br>`` `! [] (img1)! [] (img2)` ``<br>This is an image that recognizes as a two-column image and converts it into a nice-looking HTML that can be styled with CSS.|
|07:01|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|内側のコンテンツはVFMとして解釈されパースされます。VFMにはHTMLを埋め込めるため、名前付きブロックの内側ではVFMとHTML両方が使えます。|
|07:01|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: The inner content is interpreted and parsed as VFM. Since VFM can embed HTML, that is, both VFM and HTML can be used inside a named block.|
|07:16|![](https://secure.gravatar.com/avatar/1ac180f0868137292905c311b5fff781.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png)|spring-raining|PHP Markdown Extraでは同じ問題を解決するためのAttribute文法があります。 `{.class #id}` のようなAttributeを決められた場所につける拡張文法です|
|07:16|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: PHP Markdown Extra has an Attribute syntax to solve the same problem. An extended grammar that attaches an attribute such as `{.class #id}` at a certain place|
|07:19|![](https://secure.gravatar.com/avatar/1ac180f0868137292905c311b5fff781.jpg?s=72&d=https%3A%2F%2Fa.slack-edge.com%2Fdf10d%2Fimg%2Favatars%2Fava_0021-72.png)|spring-raining|任意のDiv要素が作れるかは分からないですが、例えばPandocでオプションを有効にすると以下のような変換をしてくれます<br>```## heading {#foo .bar}<pre>↓</pre>&lt;h2 id="foo" class="bar"&gt;heading&lt;/h2&gt;```|
|07:19|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: I do not know if you can create any Div element, but if you enable the option in Pandoc, for example, the following conversion will be done<br>`` `## heading {#foo .bar}` ``<br>↓<br>`` `&amp; lt; h2 id =" foo "class =" bar "&amp; gt; heading &amp; lt; / h2 &amp; gt;` ``|
|07:20|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|<https://michelf.ca/projects/php-markdown/extra/#fenced-code-blocks><br>Fenced Code Blocks知らなかった<br>めちゃくちゃ記法が似ているけど、逆に発想が間違ってないことを再確認できました😂|
|07:20|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: <https://michelf.ca/projects/php-markdown/extra/#fenced-code-blocks><br>Fenced Code Blocks I didn't know<br>It reminds me that the notation is similar, but the idea is not wrong: joy:|
|07:22|![](https://avatars.slack-edge.com/2020-01-22/916403977808_18dc4c6c299ded1b6018_72.png)|uetchy|`@spring-raining` さんが例示してくれたような、インライン記法による名前空間指定もできるようにしたいですね|
|07:22|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧:  I would like to be able to specify namespaces using inline notation as exemplified by Mr.|
|15:29|![](https://avatars.slack-edge.com/2018-04-27/354445776386_e258f5ed5ba887b08668_72.jpg)|shinyu|<blockquote>GFM のように HTML 埋め込みするものだと HTML はそのまま解釈されて内包された Markdown 記法は無視されます。</blockquote>これについて疑問に思い、GFMの HTML blocks の仕様を確認したところ、HTMLブロックは空白行を入れればそこで終わるので、開始タグと終了タグとのあいだの Markdown 記法が無視されないようにすることができます。例:<br><br>```&lt;div class="foo"&gt;<br><br>* this is *markdown* list item<br><br>&lt;/div&gt;```<br>したがって、糖衣構文を定義するのであっても、タグ＋空白行に変換することでGFMへの変換ができます。<br><br><https://github.github.com/gfm/#html-blocks>|
|15:29|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: &amp; gt; If you embed HTML like GFM, HTML will be interpreted as it is and the included Markdown notation will be ignored.<br>I wondered about this and checked the specifications of GFM's HTML blocks, HTML block ends with a blank line, so Markdown notation between start and end tags can be prevented from being ignored . Example:<br><br>`` `&amp; lt; div class =" foo "&amp; gt;<br><br>* this is * markdown * list item<br><br>&amp; lt; / div &amp; gt; `` `<br>Therefore, even if you define sugar coating syntax, you can convert to GFM by converting to tag + blank line.<br><br><https://github.github.com/gfm/#html-blocks>|
|22:21|![](https://avatars.slack-edge.com/2019-05-15/624511073651_25909952cd7a069ceed2_72.png)|akabeko|空行を入れればよかったのですね。<br>HTML タグもコード ブロックなどと同様に開始から終了までを複数行に渡って一括変換する想定でしたが、そうでないとは。|
|22:21|![](https://avatars.slack-edge.com/2019-08-21/732685848020_f3f20736795184660348_72.png)|Kiara Translation|🇬🇧: I wish I had a blank line.<br>HTML tags, like code blocks, are supposed to be converted all at once from the beginning to the end over multiple lines, but that is not the case.|
